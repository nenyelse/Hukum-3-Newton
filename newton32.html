<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulasi Tarik-Menarik di Gym</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background for gym theme */
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            padding: 2rem;
        }
        .container {
            width: 100%;
            max-width: 1024px;
            background-color: #2d3748;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            padding: 2rem;
        }
        canvas {
            background-color: #4a5568;
            border-radius: 1rem;
            width: 100%;
            touch-action: none;
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #f56565; /* Red thumb for power */
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.3s ease;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            background: #e53e3e;
        }
        .graph-container {
            background-color: #4a5568;
            border-radius: 1rem;
            padding: 1rem;
            width: 100%;
            height: 300px;
            position: relative;
        }
        .graph-label {
            position: absolute;
            font-size: 0.875rem;
            color: #a0aec0;
        }
        .graph-label.y-axis {
            transform: rotate(-90deg);
            transform-origin: 0 0;
            left: 10px;
            top: 50%;
        }
        .graph-label.x-axis {
            bottom: 10px;
            right: 10px;
        }
    </style>
</head>
<body class="bg-gray-100 p-8">

    <div class="container text-center space-y-8">
        <h1 class="text-4xl font-bold text-white mb-4">Simulasi Tarik-Menarik di Gym üèã‚Äç‚ôÇ</h1>
        <p class="text-gray-300">Siapa yang paling kuat? Lihat bagaimana gaya tarik-menarik dan gesekan mempengaruhi binaragawan dan si gemuk!</p>

        <div class="flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0 md:space-x-4">
            <div class="w-full">
                <label for="attraction-slider" class="text-left block text-sm font-medium text-gray-300">Kekuatan Tarikan: <span id="attraction-value">10</span></label>
                <input type="range" id="attraction-slider" min="1" max="50" value="10" step="0.5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            </div>
            <div class="w-full">
                <label for="mass1-slider" class="text-left block text-sm font-medium text-gray-300">Massa Binaragawan: <span id="mass1-value">5</span> kg</label>
                <input type="range" id="mass1-slider" min="1" max="20" value="5" step="0.5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            </div>
            <div class="w-full">
                <label for="mass2-slider" class="text-left block text-sm font-medium text-gray-300">Massa Si Gemuk: <span id="mass2-value">10</span> kg</label>
                <input type="range" id="mass2-slider" min="1" max="20" value="10" step="0.5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            </div>
            <div class="w-full">
                <label for="friction-slider" class="text-left block text-sm font-medium text-gray-300">Koefisien Gesekan: <span id="friction-value">0.1</span></label>
                <input type="range" id="friction-slider" min="0" max="0.5" value="0.1" step="0.01" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>

        <button id="start-btn" class="px-6 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-all duration-300 transform hover:scale-105">Mulai Latihan</button>

        <div class="border-2 border-gray-600 rounded-lg overflow-hidden">
            <canvas id="simulationCanvas" class="w-full h-64"></canvas>
        </div>

        <div class="graph-container">
            <h2 class="text-xl font-bold mb-2 text-white">Grafik Kecepatan vs Waktu</h2>
            <canvas id="velocityGraph"></canvas>
            <span class="graph-label y-axis">Kecepatan (m/s)</span>
            <span class="graph-label x-axis">Waktu (detik)</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('velocityGraph');
        const graphCtx = graphCanvas.getContext('2d');

        const attractionSlider = document.getElementById('attraction-slider');
        const mass1Slider = document.getElementById('mass1-slider');
        const mass2Slider = document.getElementById('mass2-slider');
        const frictionSlider = document.getElementById('friction-slider');
        const startBtn = document.getElementById('start-btn');

        const attractionValueSpan = document.getElementById('attraction-value');
        const mass1ValueSpan = document.getElementById('mass1-value');
        const mass2ValueSpan = document.getElementById('mass2-value');
        const frictionValueSpan = document.getElementById('friction-value');

        // Initial values
        let attractionStrength = parseFloat(attractionSlider.value);
        let m1 = parseFloat(mass1Slider.value);
        let m2 = parseFloat(mass2Slider.value);
        let mu = parseFloat(frictionSlider.value);

        // Simulation state
        let running = false;
        let time = 0;
        let lastTime = 0;
        let p1 = { x: 0, y: 0, width: 40, height: 40, velocity: 0 };
        let p2 = { x: 0, y: 0, width: 60, height: 60, velocity: 0 };
        let graphData = {
            times: [],
            v1: [],
            v2: []
        };
        let maxGraphVelocity = 0;
        let maxGraphTime = 0;

        // Dragging state
        let isDragging = false;
        let draggedBlock = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // Update slider values
        function updateValues() {
            attractionStrength = parseFloat(attractionSlider.value);
            m1 = parseFloat(mass1Slider.value);
            m2 = parseFloat(mass2Slider.value);
            mu = parseFloat(frictionSlider.value);

            attractionValueSpan.textContent = attractionStrength;
            mass1ValueSpan.textContent = m1;
            mass2ValueSpan.textContent = m2;
            frictionValueSpan.textContent = mu;
            // Adjust block sizes based on mass
            p1.width = p1.height = 30 + m1;
            p2.width = p2.height = 30 + m2;
        }

        // Reset simulation state
        function resetSimulation() {
            running = false;
            time = 0;
            p1.x = canvas.width * 0.25;
            p1.y = canvas.height / 2 - p1.height / 2;
            p1.velocity = 0;
            p2.x = canvas.width * 0.75;
            p2.y = canvas.height / 2 - p2.height / 2;
            p2.velocity = 0;
            graphData = { times: [], v1: [], v2: [] };
            maxGraphVelocity = 0;
            maxGraphTime = 0;
            draw();
            drawGraph();
        }

        // Draw the simulation
        function draw() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            // Update y positions based on new canvas height
            p1.y = canvas.height / 2 - p1.height / 2;
            p2.y = canvas.height / 2 - p2.height / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw ground line
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 20);
            ctx.lineTo(canvas.width, canvas.height - 20);
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Draw objects with a bit of stylization
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = ${p1.height - 5}px sans-serif;

            // Binaragawan (Orang 1)
            ctx.fillText(üí™, p1.x + p1.width / 2, p1.y + p1.height / 2);
            ctx.fillStyle = '#a0aec0';
            ctx.font = '12px Inter';
            ctx.fillText(Massa: ${m1}kg, p1.x + p1.width / 2, p1.y + p1.height + 15);

            // Si Gemuk (Orang 2)
            ctx.font = ${p2.height - 5}px sans-serif;
            ctx.fillText(üçî, p2.x + p2.width / 2, p2.y + p2.height / 2);
            ctx.fillStyle = '#a0aec0';
            ctx.font = '12px Inter';
            ctx.fillText(Massa: ${m2}kg, p2.x + p2.width / 2, p2.y + p2.height + 15);
            
            // Draw attractive force arrows (like a rope)
            const mid1 = p1.x + p1.width / 2;
            const mid2 = p2.x + p2.width / 2;
            drawArrow(ctx, mid1, p1.y + p1.height / 2, mid2, p1.y + p1.height / 2, 10, '#f56565');
            drawArrow(ctx, mid2, p2.y + p2.height / 2, mid1, p2.y + p2.height / 2, 10, '#4299e1');

            ctx.fillStyle = '#a0aec0';
            ctx.fillText(Tali Tarik, (mid1 + mid2) / 2, p1.y + p1.height / 2 - 15);
        }

        function drawArrow(context, fromx, fromy, tox, toy, headlen, color) {
            var angle = Math.atan2(toy - fromy, tox - fromx);
            context.strokeStyle = color;
            context.lineWidth = 3;
            context.beginPath();
            context.moveTo(fromx, fromy);
            context.lineTo(tox, toy);
            context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            context.moveTo(tox, toy);
            context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
            context.stroke();
        }

        // Draw the graph
        function drawGraph() {
            graphCanvas.width = graphCanvas.clientWidth;
            graphCanvas.height = graphCanvas.clientHeight;
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

            const padding = 30;
            const width = graphCanvas.width - 2 * padding;
            const height = graphCanvas.height - 2 * padding;

            // Draw axes
            graphCtx.beginPath();
            graphCtx.moveTo(padding, padding);
            graphCtx.lineTo(padding, height + padding);
            graphCtx.lineTo(width + padding, height + padding);
            graphCtx.strokeStyle = '#e2e8f0';
            graphCtx.lineWidth = 2;
            graphCtx.stroke();

            // Find max values for scaling
            maxGraphVelocity = Math.max(...graphData.v1.map(v => Math.abs(v)), ...graphData.v2.map(v => Math.abs(v)), 1);
            maxGraphTime = Math.max(...graphData.times, 1);

            const xScale = width / maxGraphTime;
            const yScale = height / (2 * maxGraphVelocity);
            const yOffset = height / 2 + padding;

            // Draw grid lines
            graphCtx.strokeStyle = '#4a5568';
            graphCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                // Horizontal lines
                graphCtx.beginPath();
                graphCtx.moveTo(padding, yOffset - height / 5 * i);
                graphCtx.lineTo(width + padding, yOffset - height / 5 * i);
                graphCtx.stroke();
                graphCtx.beginPath();
                graphCtx.moveTo(padding, yOffset + height / 5 * i);
                graphCtx.lineTo(width + padding, yOffset + height / 5 * i);
                graphCtx.stroke();
                // Labels
                graphCtx.fillStyle = '#a0aec0';
                graphCtx.fillText((maxGraphVelocity / 5 * i).toFixed(1), 5, yOffset - height / 5 * i + 3);
                graphCtx.fillText((-maxGraphVelocity / 5 * i).toFixed(1), 5, yOffset + height / 5 * i + 3);
            }

            // Draw velocity lines
            graphCtx.lineWidth = 2;
            
            // Velocity 1 (Binaragawan)
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#f56565';
            graphData.times.forEach((t, i) => {
                const x = padding + t * xScale;
                const y = yOffset - graphData.v1[i] * yScale;
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            });
            graphCtx.stroke();

            // Velocity 2 (Si Gemuk)
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#4299e1';
            graphData.times.forEach((t, i) => {
                const x = padding + t * xScale;
                const y = yOffset - graphData.v2[i] * yScale;
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            });
            graphCtx.stroke();

            // Draw legends
            graphCtx.fillStyle = '#f56565';
            graphCtx.fillRect(width + padding - 100, padding, 10, 10);
            graphCtx.fillText('Binaragawan', width + padding - 85, padding + 9);

            graphCtx.fillStyle = '#4299e1';
            graphCtx.fillRect(width + padding - 100, padding + 20, 10, 10);
            graphCtx.fillText('Si Gemuk', width + padding - 85, padding + 29);
        }

        // Main animation loop
        function animate(timestamp) {
            if (!running) {
                return;
            }
            if (!lastTime) {
                lastTime = timestamp;
            }
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            time += deltaTime;

            if (!isDragging) {
                const dist = (p2.x + p2.width / 2) - (p1.x + p1.width / 2);
                
                const minForceDistance = 10;
                const forceMagnitude = attractionStrength * m1 * m2 / (Math.max(minForceDistance, Math.abs(dist))) * 10;
                
                const a1 = forceMagnitude / m1 * Math.sign(dist);
                const a2 = -forceMagnitude / m2 * Math.sign(dist);

                let F_friction1 = -Math.sign(p1.velocity) * mu * m1 * 9.8;
                let F_friction2 = -Math.sign(p2.velocity) * mu * m2 * 9.8;

                p1.velocity += (a1 + F_friction1 / m1) * deltaTime;
                p2.velocity += (a2 + F_friction2 / m2) * deltaTime;
                
                p1.x += p1.velocity * deltaTime * 50;
                p2.x += p2.velocity * deltaTime * 50;

                if (p1.x + p1.width >= p2.x && p2.x + p2.width >= p1.x) {
                    const v1_new = (p1.velocity * (m1 - m2) + 2 * m2 * p2.velocity) / (m1 + m2);
                    const v2_new = (p2.velocity * (m2 - m1) + 2 * m1 * p1.velocity) / (m1 + m2);
                    p1.velocity = v1_new;
                    p2.velocity = v2_new;

                    const overlap = (p1.x + p1.width) - p2.x;
                    p1.x -= overlap / 2;
                    p2.x += overlap / 2;
                }

                if (Math.abs(p1.velocity) < 0.01) { p1.velocity = 0; }
                if (Math.abs(p2.velocity) < 0.01) { p2.velocity = 0; }
            } else {
                draggedBlock.velocity = 0;
            }

            if (p1.x <= 0) {
                p1.velocity *= -0.5;
                p1.x = 0;
            }
            if (p2.x + p2.width >= canvas.width) {
                p2.velocity *= -0.5;
                p2.x = canvas.width - p2.width;
            }

            if (graphData.times.length === 0 || time - graphData.times[graphData.times.length - 1] > 0.1) {
                graphData.times.push(time);
                graphData.v1.push(p1.velocity);
                graphData.v2.push(p2.velocity);
            }

            draw();
            drawGraph();
            requestAnimationFrame(animate);
        }

        // Event listeners
        attractionSlider.addEventListener('input', updateValues);
        mass1Slider.addEventListener('input', updateValues);
        mass2Slider.addEventListener('input', updateValues);
        frictionSlider.addEventListener('input', updateValues);
        
        startBtn.addEventListener('click', () => {
            if (!running) {
                resetSimulation();
                p1.velocity = 0.5;
                p2.velocity = -0.5;
                running = true;
                startBtn.textContent = 'Latihan Berlangsung...';
                requestAnimationFrame(animate);
            } else {
                resetSimulation();
                startBtn.textContent = 'Mulai Latihan';
            }
        });

        // Dragging event listeners
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (mouseX > p1.x && mouseX < p1.x + p1.width && mouseY > p1.y && mouseY < p1.y + p1.height) {
                isDragging = true;
                draggedBlock = p1;
                dragOffsetX = mouseX - p1.x;
                dragOffsetY = mouseY - p1.y;
                running = true;
                startBtn.textContent = 'Latihan Berlangsung...';
                requestAnimationFrame(animate);
            } else if (mouseX > p2.x && mouseX < p2.x + p2.width && mouseY > p2.y && mouseY < p2.y + p2.height) {
                isDragging = true;
                draggedBlock = p2;
                dragOffsetX = mouseX - p2.x;
                dragOffsetY = mouseY - p2.y;
                running = true;
                startBtn.textContent = 'Latihan Berlangsung...';
                requestAnimationFrame(animate);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && draggedBlock) {
                const rect = canvas.getBoundingClientRect();
                let mouseX = e.clientX - rect.left;
                
                draggedBlock.x = mouseX - dragOffsetX;
                
                if (draggedBlock.x < 0) draggedBlock.x = 0;
                if (draggedBlock.x + draggedBlock.width > canvas.width) draggedBlock.x = canvas.width - draggedBlock.width;

                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                draggedBlock = null;
            }
        });

        // Initial setup
        window.onload = () => {
            resetSimulation();
            updateValues();
        };

        window.addEventListener('resize', () => {
            resetSimulation();
        });
        resetSimulation();
        updateValues();
    </script>
</body>
</html>
